---
title: 明解C语言学习笔记
tags: C语言 学习笔记 基础
grammar_cjkRuby: true
---

# 一、基本常用函数
+ printf()

      printf("字符串%d \n",变量);
      格式化：%d,%lf,%s
      换行：\n
      报警(蜂鸣器):\a
      输出”%“,%%
      常见的printf格式化举例：
       printf("[%.4d]\n",        123);       结果：  [0123]
       printf("[%4d]\n",        123);        结果：  [  123]
       printf("[%04d]\n",       123);       结果：  [0123]
       printf("[%-4d]\n",       123);       结果：  [123  ]
       
     **注意** 如果整形数字长度大于格式化的要求，对输出结果不会造成影响
    
       printf("[%d]\n",        12345);       结果：  [12345]
       printf("[%.3d]\n",     12345);       结果：  [12345]
       printf("[%3d]\n",      12345);       结果：  [12345]
       printf("[%3d]\n",      12345);       结果：  [12345]
       
   **浮点型**
      
       printf("[%f]\n",      123.45);       结果：  [123.450000]  默认6位小数
       printf("[%.1f]\n",      123.45);       结果：  [123.4]
       printf("[%6.1f]\n",      123.45);       结果：  [  123.4] 保留一位小数，然后带小数点一共6位，前面要空出一位
       printf("[%4.1f]\n",      123.45);       结果：  [123.4]
  **输出8、16进制数**
  
      printf("%o",20); /* 输出8进制结果，24 */
      printf("%x",20); /* 输出16进制结果，14 */
      
  **输出字符串**
  
      printf("%s\n", str);   原样输出；
      printf("%3s\n",str);   至少显示3位；
      printf("%.3s\n",str);  至多显示3位；
      printf("%8s\n",str);   右对齐；
      printf("%-8s\n",str);  左对齐;
+ puts() 自带换行的printf()，不能带参数；
    
      puts("字符串")  
    
+ scanf("格式转换",&变量名)；
    把标准输入的值赋给变量名；
     字符串输出不需要&（因为第二参数为指针，字符串变量就代表字符串的首字符的指针）
     
 + putchar('字符')函数 显示字符，可以是转义字符；
 + getchar() 从标准输入流读取下一个字符（若存在），读取错误或者输入结束，返回EOF(ctrl+z）EOF通常值是-1；
 + + 函数的调用：把实参的值赋给形参，程序流转到函数体，对形参的修改不会影响到实参；
 + toupper() 将小写字母转换为大写字母；
 + tolower() 将大写字母转换为小写字母；
 
 # 二、数据类型
 
+ int （整型），赋值时会自动舍去小数；整数范围在limits.h头文件里面
+ 浮点型：（计算机不能保证其内部转换为二进制的浮点数的每一位都不发生数据丢失）**循环变量不能用浮点数**
  + double （双精度浮点数）;
  + float 80.0F 后缀为F
  + long double  80.0L 后缀为L
  + 科学计数法表示：80.0E-5 80.0* 10 *-5次方
+ 类型转换  (double) (na + nb)/2
+ typedef 声明，创建别名
  
      typedef unsigned size_t /* size_t 就成了unsigned 型的同义词 */
+ size_t 表示C语言中对象的长度，实际就是无符号的整数；
+ 整形常量的数据类型 后缀 U（无符号）、L（long型）、UL（LU）
+ 位 0/1 将位设为0以外的值，称为“设置位”
+ 负数的表示方法：
  + 反码：逐位取反；
  + 补码：逐位取反加1；
 + **数据溢出（overflow）**：超过之后的异常结果为除以最大数的余数； 
 + 枚举类型（枚举常量和数字是对应的关系）
         
         enum  枚举名 ｛枚举常量｝; /* 定义枚举类型； 
         enum  枚举名  变量名； /* 由于属于不同的命名空间，枚举名和变量名可以相同 */
         enum animal {Dog,Cat,Mouse,Chick,Invaid};
         enum animal {Dog,Cat=4,Mouse,Chick,Invaid}; /* 可以不从0开始,可以从中间改变值，可以相同
      
         enum animal selected;
        do {
            printf("请选择你想要的动物：\n 0---Dog\n 1---Cat\n 2---Mouse\n 3---Chick\n 4---Invaid\n");
            scanf("%d",&selected);
            switch(selected){
                case Dog : printf("汪汪\n"); break;
                case Cat : printf("喵喵\n"); break;
                case Mouse : printf("吱吱\n"); break;
                case Chick : printf("咯咯\n"); break;
                default :printf("啊\n");
            }
        } while(1);
  + **字符** 字符都是作为非负整数来处理的。编码具有连续性，减去0取得某个数字的编码值；
  + 转义字符：

        \a    响铃
        \b    退格  光标左移一格
        \t    水平制表符
        \v    垂直制表符
        \f    换页符
        \r    回车符
# 三、基本运算

+ %  取商只能用int型；
+ int 和 float型的转换  向上类型转换，凡是操作数中有double型的，结果都会转换为double型；
+ == 相等运算符
+ != 不相等运算符
+ 条件运算符(三目运算符)
+ && 与运算 a && b 如果a、b都为1，则结果为1，否则为0
+ ||  或运算  a || b 如果a/b的结果都为0，则结果为0，否则为1
+ a++  a--后置运算符，表达式的值是运算之前的值；
+ 条件表达式： a? b:c 如果a为真，则返回b，否则返回c 
      printf("它们的差是%d",(n1>n2)? n1-n2:n2-n1); 对两个整数判断大小的简化代码；
+ 逗号运算符
       op1,op2 依次计算每个表达式的值，并把op2的值做为表达式的值；
+ 位的逻辑运算：
  + 逻辑与 AND  a & b
  + 逻辑或 OR  a | b
  + 逻辑异或 XOR  两个位不同输出为1，相同输出为0 a ^ b
  + 逻辑非 NOT ~a
  + 移位运算 （负数因为有符号位，不要做移位运算）
    + << 左移，相当于乘以2的移位数量次方；
    + >> 右移，相当于除以2的移位数量次方；
# 四、结构化；
+ if语句 	如果“条件表达式“的值成立，则执行语句1，否则执行语句2”
	
      if(条件表达式)
    	{语句1};
      else
         {语句2};
 + switch语句： 对表达式的值进行判断，程序会转向case后面书写的值（只能是整数）与判断结果相等的部分，后面有break（可以省略）,则退出这个语句块；   
   
        switch(表达式){
        case 整数1:语句1;  break;
        case 整数2:语句2;  break;
        case 整数3:语句3; break;
        }
+ do语句 ：  先执行语句，然后判断条件表达式是否成立，如果成立，则继续循环，否则退出循环。
  	
      do{语句}
      while(条件表达式)；
      
+ while语句：先判断条件表达式是否成立，如果成立，则执行语句；

      while(条件表达式)｛
      语句;
      ｝
 + for循环语句：指定次数的循环。可以与for互换，第一个表达式和第三个可以省略；

        for(循环变量赋初值;条件判断;循环变量递增)
        ｛循环体;｝
        
 +  多重循环；
 +  函数式宏
     +  定义　
   
             #define sqr(x) ((x)*(x))  /*  定义一个算平方的宏 */ 
     + 与函数的差别：编译时就会展开，不需要传参数和返回值；注意展开的问题，如果是两个以上的表达式，则使用逗号运算符连接，使其在语法上构成一个表达式；
# 五、组成元素和格式
+ 32个关键字
      
      auto break default register signed volatile goto union extern enum typedef 等
 + 标识符
 	非数字开头，区分大小写，下划线开头一般为编译器使用，尽量不要用；
 + 分隔符；13种，各种括号，*  : ;=... #等
 + 对象式宏， 对于常量的管理比较方便，避免数值改动后需要修改多个地方的代码。
     
       #define NUMBER 5  /* 注意后面结束没有分号 */
       
 # 六、数组
 数组是相同类型对象的集合。
 结构体是不同类型的对象的集合。
+ 数组的声明：
 	类型 数组名[元素个数]; 元素个数不可以用变量，可以用常量；
    类型 数组名 = ｛元素1，元素2，……｝;
+ 数组的赋值：数组名[] ={0};把数组所有元素赋值为0；
+ 使用for循环语句实现对数组元素的显示、赋值等：
		
        int vx[] = {1,2,3,4,5}
        int i; 
		for(i=0;i<数组元素个数;i++)
        ｛printf("%d",vx[i])｝
+ C语言不支持数组的互相赋值，要对数组进行复制，只能针对于数组的全部元素逐一赋值；
+ 多维数组
	矩阵的运算:
    加法：对应元素相加做为结果;
    乘法：横和纵相乘再相加；
# 七、字符串
带双引号的一系列字符，末尾事结束符（null）\0，长度是所有字符+结束符的长度。
	
+ 字符串的初始化

		char ss[] = {'A','B','C','\0'};
        char ss[] = "ABC";
+ 字符串的赋值：除了初始化，不能直接赋值；
+ 字符串读取
     
       scanf("%s",str);
 + 字符串处理
         
        字符串长度计算方法
         while(str[len] != 0)  /* 判断没有结束 */
            len++;
            putchar(str[len]) /* 遍历 */
 + 用二维数组表示字符串数组；
# 八、指针
指针其实就是指向变量地址，函数调用时不可以修改传入参数的值，但是可以通过指针来修改；
当指针ptr的值为对象X的地址时，一般说ptr指向x
+ 指针的声明  

      int *ptr; /* 指向int型变量的指针 ptr */
      *ptr 表示指针ptr指向的变量值；
      &变量名，表示变量的地址，也就是指针；
+ 指针和函数：当传入到函数的参数是指针时 ，可以通过指针修改参数的值；
+ **注意**：函数形参中的“\*ptr” 和函数语句体中的“\*ptr”是不同的，一个代表是指针型变量，一个指的是指针指向的变量；
+ 指针和数组：指针+i是指向指针所指对象后第i元素的指针，而不管数组的类型占用多少内存，反之亦然；

		vc[2]   *(ptr + 2)  ptr[2]  /* 前面三个表示同样的东西，都表示数组vc的第三个元素*/
    	程序中不带下标运算符而单独出现的数组名，会被视为指向该数组的第一个元素的指针；
        即：vc就是&vc[0] （除非sizeof(数组名)，&数组名，指向数组的指针）
 + 指针之间也可以用关系运算符和双目运算符进行减法计算，算出之间相隔几个元素；
 + 数组的传递 ：在形参中不需要指明是指针型，但实际调用时用不带下标的数组名即可

		int int_set(int vc[],int no,int val)
        {
            int i;
            for(i=0;i<no;i++)
                vc[i] = val;
        }
        int main()
        {
            int ary[] = {1,2,3,4,5};
            int_set(ary,5,0);
            int i;
            for(i=0;i<5;i++)
                printf("ary[%d] = %d\n",i,ary[i]);
         ｝
# 重要概念：
+ **作用域（scope）：**
  + 块作用域：在程序块中声明的变量，只在该程序块中生效（函数，main函数）；
  + 文件作用域：在主函数外声明的变量，从声明开始的起到程序的结尾都是通用的；
  + 如果两个同名变量分别拥有文件作用域和块作用域，那么只有拥有块作用域的变量是“可见”的，而拥有文件作用域的变量会被“隐藏”起来；
+ **存储期**（storage duration）:
    + 自动存储期：不使用static存储类说明符定义出的对象（变量）。程序执行到对象声明的时候就创建出了相应的对象，而执行到包含该声明的程序块的结尾，就是大括号的时候，该对象就会消失；
    + 静态存储期：在函数中使用static定义出的对象，或者是在函数外声明定义出的对象。在程序开始执行的时候，具体说是在main函数执行之前的准备阶段被创建出来，在程序结束的时候消失，永久；如果没有赋初始值，自动初始化为0；
+ **定义和声明：** 定义就是定义一个函数，声明就是在函数定义前使用需要做的事；调用的函数一般放在main()前面；声明时可以不指定形参的名称；
+  函数的通用性：创建一个函数尽可能要使其可以通用，提高代码的利用率；
+  const 修饰符：不可以修改带入形参的变量值；
+  空语句（null statement）； 一个分号的语句，不需要执行什么，常用于循环或者条件中；
# 简单的算法实现
+ 1、变量值的交换：通过临时变量

      int a=10,
      int b=4;
      int temp=0;
      temp = a;
      a = b;
      b = temp;
 
 + 2、求最大值和最小值：把第一个值赋给最大值变量，依次判断每一个元素，如果小于 ，什么也不做，如果大于最大值变量，则把这个元素的值赋给最大值变量（反之亦然）；
+ 3、质数的计算；
+ 4、查找方式：
  + 顺序查找法：依次遍历要查找的元素，只到找到符合条件的；
  + 哨兵查找法：将所要查找的key放在最后，可以减少一个判断，简化代码，如果查找的索引值等于元素个数(到最后一个)，说明查找失败，示范代码如下，在有个no个元素的数组vc中查找key的值；
       
         int search(int vc[],int key,int no)
         {
             int i=0;
             vc[no] = key;
             while(1){
                if(vc[i] == key)
                   break;
                i++;
                }
             return (i == no ? FAILED:i);
         }
 + 5 递归 要进行某些计算或操作时，如果其实现方法正好是与自身相同的函数，这种调用就被称为递归函数调用；
   + 阶乘算法的递归调用代码；
         
         int jiechen(int n)
          {
              if(n > 0)
                  return(n*jiechen(n-1));
              else
                  return(1);
            ｝
    + 最大公约数算法：两个整数，如果大的除以小的，余数为0，那么最大公约数就是小的，如果不是，小的作为大的，余数作为小的；形象地解释为从剩下的长方开形中分出正文形，直到全部都是正方形；
    
          int maxgy(int  vx,int vy)
          {
                return(vy==0?vx:maxgy(vx,vx%vy));               
          {
              
          int vx,vy;
          printf("请输入2个整数：");
          scanf("%d%d",&vx,&vy);
          printf("这两个数的最大公约数是：%d",(vx>vy)? maxgy(vx,vy):maxgy(vy,vx));
# 常见的错误

+ 多个声明变量赋值；

      正确： int a=0,b=0; 
      int a ,b;
      a=b=0;
      错误：int a=b=0;
      
      
    